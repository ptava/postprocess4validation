from numpy import ndarray
from dataclasses import dataclass, field
from typing import Dict, Optional, List, Set, Tuple
from numpy.typing import NDArray
from matplotlib.axes import Axes

from .point_data import PointData
from .visualization import get_distinct_color
from .utils import logger, Info


@dataclass
class Line:
    """
    Time-dependent field data along a named line that must be parallel to one 
    of the X, Y, or Z axes

    Parameters
    ----------
    tag (str): the tag of the plane where the line belongs
    plane_position: fixed coordinate of the plane where line belongs
    line_position: fixed coordinate of the line where its values belong
        DataSet -> _generate_line_naming(plane_position, line_postion)
    values (optional, Dict): Nested dictionary with following structure
        {
            "source_0": {
                "field_0": {
                    time_0: np.ndarray(shape=(n, 2)),
                    time_1: np.ndarray(shape=(n, 2))
                    ...
                },
                "field_1": {
                    time_0: np.ndarray(shape=(n, 2))
                    time_1: np.ndarray(shape=(n, 2))
                }
            },
            "source_1": {
                ...
            }
        }
    name (str): line name automatically defined based on 'plane_position' and
        'line_position'
    """

    tag: str
    plane_position: float
    line_position: float
    name: str = field(init=False)
    values: Dict[str, Dict[str, Dict[float, ndarray]]] = field(
        default_factory=dict, init=False, repr=False)
    _colors: List[Tuple[float, float, float]] = field(
        default_factory=list, init=False, repr=False)
    _points: List[PointData] = field(
        default_factory=list, init=False, repr=False)
    _fields: Set[str] = field(default_factory=set, init=False, repr=False)
    _sources: List[str] = field(default_factory=list, init=False, repr=False)
    _labels: List[str] = field(default_factory=list, init=False, repr=False)
    _axis: str = field(default="", init=False, repr=False)
    _x: Optional[float] = field(default=None, init=False, repr=False)
    _y: Optional[float] = field(default=None, init=False, repr=False)
    _z: Optional[float] = field(default=None, init=False, repr=False)

    def __post_init__(self) -> None:
        """
        Takes coordinates and returns a string name for the line.
        All coordinates are rounded to the last valuable digit

        Notes:
        -----
        The line name is generated by concatenating the line fixed coordina-
        te in the plane and the fixed coordinate of the plane. With this no-
        tation the name is unique.
        The coordinates are defined only with meaningful digits.
        """
        # Set name
        self.name = (
            "line" \
            f"_{self.line_position:.15g}" \
            f"_{self.plane_position:.15g}"
        )

    # --- Dunder methods --- #
    def __str__(self) -> str:
        string = (
            f"<Line {self.name!r} (sources = {self.sources})>"
        )
        return string

    def __getitem__(self, source: str, field: str) -> Dict[float, ndarray]:
        return self.values[source][field]

    # --- Public methods --- #
    def add_color(self, color: NDArray) -> None:
        """Add a color to the line."""
        if len(color) != 3 or not all(0 <= c <= 255 for c in color):
            raise ValueError(f"Color must be a list of 3 integers (0-255) – got {color}")
        color_as_tuple = tuple(color)
        self._colors.append(color_as_tuple)

    def add_point_if_belong(self, point: PointData) -> None:
        """Add a point to the line."""
        if not self.does_point_belong(point):
            return
        self._points.append(point)

    def add_label(self, label: str) -> None:
        """Add a label to the line."""
        self._labels.append(label)

    def clear_colors(self) -> None:
        """Clear all colors from the line"""
        self._colors.clear()

    def clear_labels(self) -> None:
        """Clear all labels from the line"""
        self._labels.clear()

    def add_field_name(self, field: str) -> None:
        """Add a field to the line."""
        self._fields.add(field)

    def add_data(self, source: str, field: str, time: float, arr: ndarray) -> None:
        """Store a 2-column array for a given field at a specific time."""
        if arr.ndim != 2 or arr.shape[1] != 2:
            raise ValueError(
                "value must be an ndarray of shape (n, 2) – got " f"{arr.shape}"
            )
        source_dict = self.values.setdefault(source, {})
        source_dict.setdefault(field, {})[time] = arr
        logger.debug(f"Line {self.name}: stored {field} at t={time} "
            f"(nrows={arr.shape[-1]})")

    def update_with_data(self, source: str, data: Dict[str, Dict[float, ndarray]]) -> None:
        """Merge a nested dictionary into current values."""
        for field, time_series in data.items():
            self.add_field_name(field)
            for time, arr in time_series.items():
                self.add_data(source, field, time, arr)

    def get_field_at(self, source: str, field: str, t: float) -> ndarray:
        """Return the 2‑column array for *field* at *t* (KeyError if missing)."""
        try:
            return self.values[source][field][t]
        except KeyError:
            raise KeyError(
                f"Field {field!r} at time {t} not found for source {source!r}"
                f"in line {self.name!r}."
            )

    def get_times(self, source: str, field: str) -> List[float]:
        """Return a sorted list of time steps for a given source and field."""
        try:
            time_values = list(self.values[source][field].keys())
            return sorted(time_values)
        except KeyError:
            raise KeyError(
                f"Field {field!r} not found for source {source!r} in line "
                f"{self.name!r}."
            )

    def stats(self, source: str, field: str, time: float) -> Dict[str, float]:
        """Simple descriptive stats on the *y* column for a field at `t`."""
        arr = self.get_field_at(source, field, time)
        ys = arr[:, 1]
        return {
            "min": float(ys.min()),
            "max": float(ys.max()),
            "mean": float(ys.mean()),
        }

    def has_data(self) -> bool:
        """Check if the line has any data."""
        return len(self.sources) > 0

    def does_point_belong(self, point: PointData) -> bool:
        """
        Check if the point belongs to this line.

        Exploit tag and line_position to determine if the point belongs to the
        line

        Parameters
        ----------
        point (PointData): the point to check.

        Returns
        -------
        bool: True if the point belongs to the line, False otherwise.
        """
        for char in self.tag:
            coord = getattr(point, f"_{char.lower()}")
            if coord == self.line_position and char != self.axis:
                return True
        return False

    def set_line_info(
            self,
            flow_direction: str,
            possible_characters: Set = Info.SUPPORTED_CHARACTERS
    ) -> None:
        """ Set the axis and fixed coordinates of the line based on the tag and
        flow direction """
        # For construction the flow direction has to be in the tag
        if flow_direction not in self.tag:
            raise ValueError(
                f"Flow direction {flow_direction!r} is not in the tag {self.tag!r}."
            )

        # Set axis
        for char in self.tag:
            if char != flow_direction:
                self._axis = char

        # Set fixed coordinates
        for char in possible_characters:
            if char != self._axis:
                if char in self.tag:
                    # assign line position to the corresponding coordinate
                    setattr(self, f"_{char.lower()}", self.line_position)
                else:
                    # assign plane position to the corresponding coordinate
                    setattr(self, f"_{char.lower()}", self.plane_position)

    def add_to_plot(self, 
                    ax: Axes,
                    field_name: str, 
                    last_time_only: bool,
                    line_marker: str = '-',
                    scale: float = 1.0) -> None:
        """ Plot the data of the line on the given axes applying scale on first
        axis and using the last time step only if specified. """

        # Add line positioning
        ax.axvline(
            self.line_position, #type: ignore
            color="tab:gray",
            linestyle='--',
            linewidth=0.5,
        )

        # Add line data for each source for the current field
        color_counter = 0   # start color counter
        self.clear_labels() # make sure to start with empty labels list
        self.clear_colors() # make sure to start with empty colors list

        for source in self.sources:
            times = self.get_times(source, field_name)

            if last_time_only:
                times = [times[-1]]

            for time in times:
                current_value = self.get_field_at(source, field_name, time)
                current_color = get_distinct_color(color_counter)
                x_values = self.line_position + current_value[:, 1] * scale
                y_values = current_value[:, 0]
                ax.plot(
                    x_values,
                    y_values,
                    color=current_color,
                    linestyle=line_marker,
                )
                self.add_color(current_color)
                self.add_label(str(time) if not last_time_only else source)
                color_counter += 1


            logger.debug(
                    f"Line {self.name}: plotted {len(times)} time steps "
                    f"[{source!r} -> {field_name!r}]"
            )

    # --- Properties --- #
    @property
    def sources(self) -> List[str]:
        """List of sources that have data for this line."""
        return list(self.values.keys())

    @property
    def points(self) -> List[PointData]:
        """List of points with data associated to the line"""
        return self._points

    @property
    def fields(self) -> Set[str]:
        """Set of fields available for this line."""
        return self._fields

    @property
    def x(self) -> Optional[float]:
        """X coordinate of the line."""
        return self._x

    @property
    def y(self) -> Optional[float]:
        """Y coordinate of the line."""
        return self._y

    @property
    def z(self) -> Optional[float]:
        """Z coordinate of the line."""
        return self._z

    @property
    def axis(self) -> str:
        """Axis along which the line is defined."""
        return self._axis

    @axis.setter
    def axis(self, value: str) -> None:
        """Set the axis along which the line is defined."""
        if value not in ("X", "Y", "Z"):
            raise ValueError(f"Invalid axis {value!r}. Must be 'X', 'Y', or 'Z'.")
        self._axis = value

    @property
    def colors(self) -> List[Tuple[float, float, float]]:
        """Color of the line."""
        return self._colors

    @property
    def labels(self) -> List[str]:
        """Labels for the line."""
        return self._labels

